(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{786:function(t,e,v){"use strict";v.r(e);var o=v(58),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"面试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面试"}},[t._v("#")]),t._v(" 面试")]),t._v(" "),v("h2",{attrs:{id:"自我介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自我介绍"}},[t._v("#")]),t._v(" 自我介绍")]),t._v(" "),v("p",[t._v("大概了解情况,根据所说的继续提问")]),t._v(" "),v("h2",{attrs:{id:"介绍项目"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍项目"}},[t._v("#")]),t._v(" 介绍项目")]),t._v(" "),v("p",[t._v("根据所介绍的项目进行追问")]),t._v(" "),v("h2",{attrs:{id:"介绍一下你会的前端技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下你会的前端技术"}},[t._v("#")]),t._v(" 介绍一下你会的前端技术")]),t._v(" "),v("p",[t._v("主要看会哪些技术,后面根据所说的技术栈进行提问")]),t._v(" "),v("h2",{attrs:{id:"项目"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#项目"}},[t._v("#")]),t._v(" 项目")]),t._v(" "),v("p",[t._v("接口是怎么管理的"),v("br"),t._v("\ncontainer这么实现上下固定,中间自适应的布局"),v("br"),t._v("\n路由是怎么控制角色的")]),t._v(" "),v("h2",{attrs:{id:"过关条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过关条件"}},[t._v("#")]),t._v(" 过关条件")]),t._v(" "),v("ol",[v("li",[t._v("实习的,js基础扎实,熟悉es6语法,用过vue即可")]),t._v(" "),v("li",[t._v("社招的,js基础扎实,精通js高级语法,es6高级语法等,promise,async/await,闭包,原型,继承,类等,精通vue,生命周期熟悉,axios熟练,了解响应式原理,熟练使用vueRouter,了解导航守卫的作用,能讲出多种导航钩子,具体用法和项目中的流程,能说出登录流程,权限控制流程,导航守卫的流程,熟悉vuex,知道state,action,multion,getter的作用即可,elementui使用度如何,有哪些需要二次开发的功能,如果管理接口的api")])]),t._v(" "),v("h3",{attrs:{id:"js基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js基础"}},[t._v("#")]),t._v(" js基础")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("js的事件循环机制"),v("br"),t._v("\njs的循环机制："),v("br"),t._v("\njs是单线程，所有的代码都要通过函数调用栈执行，在执行函数时，如果有异步函数或是setTimeout、setInterval等会交给浏览器内核执行，然后将回调函数放进任务队列中，函数调用栈执行完后会去任务队列查找是否有任务，按优先级执行")])]),t._v(" "),v("li",[v("p",[t._v("js的事件处理机制\njs的事件处理机制可以分为3个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段"),v("br"),t._v("\n事件捕获阶段：document发出事件流从document节点开始往下一层层查找"),v("br"),t._v("\n处于目标阶段：事件流到达响应事件所在节点，并执行同名函数"),v("br"),t._v("\n事件冒泡阶段：事件流从目标节点往document节点一层层冒泡，如果遇到与目标函数同名函数则会被触发")])]),t._v(" "),v("li",[v("p",[t._v("js原型链的理解\n任何javascript对象都有一个prototype或_proto_属性指向它的构造函数的prototype"),v("br"),t._v("\n我理解的原型链：其实就是javascript的继承机制，是指获取JavaScript对象的属性会顺着其_proto_的指向寻找，直至找到Object.prototype上")])]),t._v(" "),v("li",[v("p",[t._v("如何改变this的指向,都有什么区别\nnew操作符"),v("br"),t._v("\ncall()、apply()、bind()")])]),t._v(" "),v("li",[v("p",[t._v("你是怎么理解闭包的")])]),t._v(" "),v("li",[v("p",[t._v("Javascript如何实现继承？")])])]),t._v(" "),v("blockquote",[v("p",[t._v("构造继承，原型继承，（实例继承，拷贝继承）。构造函数继承可以将构造函数的属性拷贝给实例（＊.call(this,[])）。但是缺点是无法实现函数复用。原型继承可以实现函数复用，但是所有实例共享一个属性，任意一个实例改变原型属性都会改变其它实例的属性值。推荐采用构造函数继承传递属性（拷贝），原型继承传递方法")])]),t._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[v("p",[t._v("用原生JavaScript的实现过什么功能吗?")])]),t._v(" "),v("li",[v("p",[t._v("说一下promise")])]),t._v(" "),v("li",[v("p",[t._v("会使用async/await吗?")])]),t._v(" "),v("li",[v("p",[t._v("es6掌握的怎么样?说一下你经常使用哪些es6的特性"),v("br"),t._v("\n1.新增let\\const 声明方式"),v("br"),t._v("\n2.箭头函数"),v("br"),t._v("\n3.解构（数组解构和对象解构）"),v("br"),t._v("\n4.Promise"),v("br"),t._v("\n5.Class,继承的显示化"),v("br"),t._v("\n6.新增Symbol数据类型\n7.Set和Map集合"),v("br"),t._v("\n8.字符串模板"),v("br"),t._v("\n9.Generator生成器"),v("br"),t._v("\n10.函数参数默认值"),v("br"),t._v("\n11.函数参数简写即字面量提升"),v("br"),t._v("\n————————————————")])]),t._v(" "),v("li",[v("p",[t._v("说一下节流和防抖,项目中怎么运用\n防抖是在调用函数时只执行最后一次\n节流是在指定时间内只调用一次")])])]),t._v(" "),v("h3",{attrs:{id:"vue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" vue")]),t._v(" "),v("ol",{attrs:{start:"0"}},[v("li",[v("p",[t._v("封装组件的思路")])]),t._v(" "),v("li",[v("p",[t._v("keepAlive是用来干什么的")])]),t._v(" "),v("li",[v("p",[t._v("针对element-ui组件更改样式在scoped里不生效的解决方案")])]),t._v(" "),v("li",[v("p",[t._v("双向数据绑定原理")])]),t._v(" "),v("li",[v("p",[t._v("什么是vue的生命周期？")])])]),t._v(" "),v("blockquote",[v("p",[t._v("Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM->渲染、更新->渲染、卸载等一系列过程，我们称这是Vue的生命周期。")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("vue生命周期的作用是什么？")])]),t._v(" "),v("blockquote",[v("p",[t._v("它的生命周期中有多个事件钩子，让我们在控制整个vue实例的过程时更容易形成好的逻辑。")])]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("Vue生命周期总共有几个阶段？")])]),t._v(" "),v("blockquote",[v("p",[t._v("它可以总共分为8个阶段：创建前/后,载入前/后，更新前/后，销毁前/销毁后")])]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("第一次页面加载会触发那几个钩子？")])]),t._v(" "),v("blockquote",[v("p",[t._v("第一次页面加载时会触发beforeCreate,created,beforeMount,mounted")])]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("DOM渲染在哪个周期中就已经完成？")])]),t._v(" "),v("blockquote",[v("p",[t._v("DOM渲染在mounted中就已经完成了")])]),t._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[t._v("生命周期钩子的一些使用方法：")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("解答")]),t._v(" "),v("ol",[v("li",[t._v("beforecreate:可以在加个loading事件，在加载实例是触发")]),t._v(" "),v("li",[t._v("created:初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用")]),t._v(" "),v("li",[t._v("mounted:挂载元素，获取到dom节点")]),t._v(" "),v("li",[t._v("updated:如果对数据统一处理，在这里写上相应函数")]),t._v(" "),v("li",[t._v("beforeDestroy:可以一个确认停止事件的确认框")]),t._v(" "),v("li",[t._v("nextTick:更新数据后立即操作dom")])])]),t._v(" "),v("ol",{attrs:{start:"7"}},[v("li",[t._v("v-show与v-if的区别")])]),t._v(" "),v("blockquote",[v("p",[t._v("v-show是css切换，v-if是完整的销毁和重新创建,使用频繁切换时用v-show,运行时较少改变时用v-if")])]),t._v(" "),v("ol",{attrs:{start:"8"}},[v("li",[v("p",[t._v("开发中常用的指令有哪些?")])]),t._v(" "),v("li",[v("p",[t._v("绑定class的数组用法")])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("解答")]),t._v(" "),v("ol",[v("li",[t._v("对象方法v-bind:class=\"{'orange':isRipe, 'green':isNotRipe}”")]),t._v(" "),v("li",[t._v('数组方法v-bind:class="[class1,class2]"')]),t._v(" "),v("li",[t._v("行内v-bind:style=\"{color:color,fontSize:fontSize+'px'}”")])])]),t._v(" "),v("ol",{attrs:{start:"10"}},[v("li",[t._v("路由跳转方式")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("解答")]),t._v(" "),v("ol",[v("li",[t._v("router-link标签会渲染为标签，咋填template中的跳转都是这种；")]),t._v(" "),v("li",[t._v("另一种是编辑是导航，也就是通过js跳转比如router.push('/home')")])])]),t._v(" "),v("ol",{attrs:{start:"11"}},[v("li",[t._v("MVVM")])]),t._v(" "),v("p",[t._v("M-model，model代表数据模型，也可以在model中定义数据修改和操作的业务逻辑")]),t._v(" "),v("p",[t._v("V-view,view代表UI组件，它负责将数据模型转化为UI展现出来")]),t._v(" "),v("p",[t._v("VM-viewmodel,viewmodel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步view和model的对象，连接model和view\n12. computed和watch有什么区别")]),t._v(" "),v("p",[t._v("computed")]),t._v(" "),v("p",[t._v("computed是计算属性，也就是计算值，它更多用于计算值的场景\ncomputed具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算\ncomputed适用于计算比较消耗性能的计算场景\nwatch")]),t._v(" "),v("p",[t._v("watch更多的是[观察]的作用，类似于某些数据的监听回调，用于观察props $emit或者本组件的值，当数据变化时来执行回调进行后续操作\n无缓存性，页面重新渲染时值不变化也会执行\n小结")]),t._v(" "),v("p",[t._v("当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed\n如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。\n13. vue组件的scoped属性的作用")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("解答")]),t._v(" "),v("p",[t._v("在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；\n但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的；\n解决办法：")]),t._v(" "),v("p",[t._v("①：使用混合型的css样式：（混合使用全局跟本地的样式） ")]),v("style",[t._v(" /* 全局样式 <em>/ ")]),v("style",{attrs:{scoped:""}},[t._v(" /</em> 本地样式 <em>/ ")]),t._v("\n②：深度作用选择器（>>>）如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 >>> 操作符："),v("style",{attrs:{scoped:""}},[t._v(" .a &gt;&gt;&gt; .b { /</em> ... */ } ")]),v("p")]),t._v(" "),v("ol",{attrs:{start:"14"}},[v("li",[t._v("vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)")])]),t._v(" "),v("p",[t._v("Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。如下图所示，这里包含了Vue的所有部件，在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念\n在我看来，渐进式代表的含义是：主张最少。视图模板引擎\n每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。\n比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：\n必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）\n所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。\nVue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。\n渐进式的含义，我的理解是：没有多做职责之外的事。\n15. vue.js的两个核心是什么(数据驱动、组件系统。)")]),t._v(" "),v("p",[t._v("数据驱动:Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制,核心是VM，即ViewModel，保证数据和视图的一致性。\n组件系统:点此查看\n16. vue常用修饰符")]),t._v(" "),v("ol",{attrs:{start:"17"}},[v("li",[v("p",[t._v("v-on可以监听多个方法吗？（可以的）")])]),t._v(" "),v("li",[v("p",[t._v("vue事件中如何使用event对象")])])]),t._v(" "),v("p",[v("code",[t._v('<button @click="Event($event)">事件对象</button>')]),t._v("\n19. 比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。")]),t._v(" "),v("ol",{attrs:{start:"20"}},[v("li",[t._v("Vue 组件中 data 为什么必须是函数")])]),t._v(" "),v("blockquote",[v("p",[t._v("vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。")])]),t._v(" "),v("ol",{attrs:{start:"21"}},[v("li",[t._v("vue中子组件调用父组件的方法")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("解答")]),t._v(" "),v("p",[t._v("第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法\n第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。\n第三种都可以实现子组件调用父组件的方法，")])]),t._v(" "),v("ol",{attrs:{start:"22"}},[v("li",[t._v("vue中 keep-alive 组件的作用")])]),t._v(" "),v("blockquote",[v("p",[t._v("keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。")])]),t._v(" "),v("ol",{attrs:{start:"23"}},[v("li",[v("p",[t._v("vue中如何编写可复用的组件？")])]),t._v(" "),v("li",[v("p",[t._v("什么是vue生命周期和生命周期钩子函数？")])])]),t._v(" "),v("p",[t._v('beforecreated：在实例初始化之后，el 和 data 并未初始化（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到；）\ncreated:完成了 data 数据的初始化，el没有（这个时候可以操作vue实例中的数据和各种方法，但是还不能对"dom"节点进行操作；）\nbeforeMount：完成了 el 和 data 初始化 //这里的el是虚拟的dom；\nmounted ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行）\nbeforeUpdate：是指view层数据变化前，不是data中的数据改变前触发；\nupdate：是指view层的数据变化之后，\nbeforeDestory： 你确认删除XX吗？\ndestoryed ：当前组件已被删除，清空相关内容\nA、什么是vue生命周期？\nVue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。\nB、vue生命周期的作用是什么？\n它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。\nC、vue生命周期总共有几个阶段？\n它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后\nD、第一次页面加载会触发哪几个钩子？\n第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子\nE、DOM 渲染在 哪个周期中就已经完成？\nDOM 渲染在 mounted 中就已经完成了。\nF、简单描述每个周期具体适合哪些场景？\n生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom;\n25. vue更新数组时触发视图更新的方法')]),t._v(" "),v("p",[t._v("Vue.set    ==========Vue.set(target,key,value)这个方法主要是用于避开vue不能检测属性被添加的限制\nVue.set(array, indexOfItem, newValue)//indexOfItem指的索引\nthis.array.$set(indexOfItem, newValue)\nVue.set(obj, keyOfItem, newValue)\nthis.obj.$set(keyOfItem, newValue)\nVue.delete   这个方法主要用于避开vue不能检测到属性被删除；")]),t._v(" "),v("p",[t._v("Vue.delete(array, indexOfItem)\nthis.array.$delete(indexOfItem)\nVue.delete(obj, keyOfItem)\nthis.obj.$delete(keyOfItem)")]),t._v(" "),v("ol",{attrs:{start:"28"}},[v("li",[t._v("什么是vue的计算属性computed")])]),t._v(" "),v("p",[t._v("计算属性是需要复杂的逻辑，可以用方法method代替")]),t._v(" "),v("p",[t._v("computed:{\ntotalPrice(){\nreturn (this.good.price*this.good.count)*this.discount+this.deliver;\n}\n}\n29. vue-cli提供的几种脚手架模板")]),t._v(" "),v("p",[t._v("vue-cli 的脚手架项目模板有browserify 和 webpack；\n30. 组件中传递数据？")]),t._v(" "),v("p",[t._v("props：export default {\nprops: {")]),t._v(" "),v("p",[t._v("message: String //定义传值的类型"),v("br")]),t._v(" "),v("p",[t._v("},")]),t._v(" "),v("p",[t._v('//或者props:["message"]')]),t._v(" "),v("p",[t._v("data: {}")]),t._v(" "),v("p",[t._v("父组件调用子组件的方法：父组件   this.$refs.yeluosen.childMethod()")]),t._v(" "),v("p",[t._v("子组件向父组件传值并调用方法 $emit")]),t._v(" "),v("p",[t._v("组件之间：bus==$emit+$on\n31. vue-router实现路由懒加载（ 动态加载路由 ）")]),t._v(" "),v("ol",{attrs:{start:"32"}},[v("li",[t._v("vue-router 的导航钩子,主要用来作用是拦截导航,让他完成跳转或取消。")])]),t._v(" "),v("p",[t._v("全局的:前置守卫、后置钩子（beforeEach，afterEach）beforeResolve\n单个路由独享的:beforeEnter\n组件级的: beforeRouteEnter（不能获取组件实例 this）、beforeRouteUpdate、beforeRouteLeave\n这是因为在执行路由钩子函数beforRouteEnter时候，组件还没有被创建出来；\n先执行beforRouteEnter，再执行组件周期钩子函数beforeCreate，可以通过 next 获取组件的实例对象，如：next( (vm)=>{} )，参数vm就是组件的实例化对象。\n33. 完整的 vue-router 导航解析流程")]),t._v(" "),v("p",[t._v("1.导航被触发；\n2.在失活的组件里调用beforeRouteLeave守卫；\n3.调用全局beforeEach守卫；\n4.在复用组件里调用beforeRouteUpdate守卫；\n5.调用路由配置里的beforeEnter守卫；\n6.解析异步路由组件；\n7.在被激活的组件里调用beforeRouteEnter守卫；\n8.调用全局beforeResolve守卫；\n9.导航被确认；\n10..调用全局的afterEach钩子；\n11.DOM更新；\n12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数。")]),t._v(" "),v("ol",{attrs:{start:"35"}},[v("li",[t._v("vue-router的几种实例方法以及参数传递")])]),t._v(" "),v("p",[t._v("name传递\nto来传递\n采用url传参\n36. is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）")]),t._v(" "),v("p",[t._v("is用来动态切换组件，DOM模板解析")]),t._v(" "),v("p",[v("code",[t._v('<table> <tr is="my-row"></tr> </table>')]),t._v("\n37. vuex是什么？怎么使用？哪种功能场景使用它？")]),t._v(" "),v("p",[t._v("是什么：vue框架中状态管理:有五种，分别是 State、 Getter、Mutation 、Action、 Module\n使用：新建一个目录store，\n场景：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\nvuex的State特性\nA、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data\nB、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新\nC、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中")]),t._v(" "),v("p",[t._v("vuex的Getter特性\nA、getters 可以对State进行计算操作，它就是Store的计算属性\nB、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用\nC、 如果一个状态只在一个组件内使用，是可以不用getters")]),t._v(" "),v("p",[t._v("vuex的Mutation特性\n改变store中state状态的唯一方法就是提交mutation，就很类似事件。\n每个mutation都有一个字符串类型的事件类型和一个回调函数，我们需要改变state的值就要在回调函数中改变。\n我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。")]),t._v(" "),v("p",[t._v("Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；\nAction 可以包含任意异步操作，Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，\n因此你可以调用 context.commit 提交一个 mutation，\n或者通过 context.state 和 context.getters 来获取 state 和 getters。\nAction 通过 store.dispatch 方法触发：eg。\nstore.dispatch('increment')")]),t._v(" "),v("p",[t._v("vuex的module特性\nModule其实只是解决了当state中很复杂臃肿的时候，module可以将store分割成模块，\n每个模块中拥有自己的state、mutation、action和getter")]),t._v(" "),v("p",[t._v("原型,原型链,继承,闭包,new运算符执行过程, 防抖与节流,this")])])}),[],!1,null,null,null);e.default=a.exports}}]);