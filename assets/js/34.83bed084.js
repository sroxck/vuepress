(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{572:function(t,v,_){t.exports=_.p+"assets/img/smzq.2dd7ed49.png"},876:function(t,v,_){"use strict";_.r(v);var e=_(58),r=Object(e.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期"}},[t._v("#")]),t._v(" react 生命周期")]),t._v(" "),e("ul",[e("li",[t._v("生命周期: 组件从被创建到挂载到页面中运行,再到组件不用时卸载的过程")]),t._v(" "),e("li",[t._v("钩子函数: 生命周期每个阶段伴随这一些方法调用,这些方法就是生命周期的钩子函数")]),t._v(" "),e("li",[t._v("钩子函数的作用: 为开发人员在不同阶段操作组件")]),t._v(" "),e("li",[t._v("只有类组件才有生命周期")])]),t._v(" "),e("h2",{attrs:{id:"生命周期的三个阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期的三个阶段"}},[t._v("#")]),t._v(" 生命周期的三个阶段")]),t._v(" "),e("p",[e("img",{attrs:{src:_(572),alt:"img"}})]),t._v(" "),e("p",[e("strong",[t._v("学习目标:")])]),t._v(" "),e("ol",[e("li",[t._v("每个阶段的执行时机")]),t._v(" "),e("li",[t._v("每个阶段钩子函数执行的顺序")]),t._v(" "),e("li",[t._v("每个阶段钩子函数的作用")])]),t._v(" "),e("h3",{attrs:{id:"创建时-挂载阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建时-挂载阶段"}},[t._v("#")]),t._v(" 创建时(挂载阶段)")]),t._v(" "),e("p",[t._v("执行顺序: "),e("code",[t._v("constructor")]),t._v(" -> "),e("code",[t._v("render")]),t._v(" -> "),e("code",[t._v("componentDidMount")])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("钩子函数")]),t._v(" "),e("th",[t._v("触发时机")]),t._v(" "),e("th",[t._v("作用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("constructor")]),t._v(" "),e("td",[t._v("创建组件时,最先执行")]),t._v(" "),e("td",[t._v("1.初始化state  2. 为事件处理程序绑定this")])]),t._v(" "),e("tr",[e("td",[t._v("render")]),t._v(" "),e("td",[t._v("每次组件渲染都会触发")]),t._v(" "),e("td",[t._v("渲染UI  (注意: 不能调用setState())")])]),t._v(" "),e("tr",[e("td",[t._v("componentDidMount")]),t._v(" "),e("td",[t._v("组件挂载(完成DOM渲染)后")]),t._v(" "),e("td",[t._v("1. 发送网络请求 2. DOM操作")])])])]),t._v(" "),e("h3",{attrs:{id:"更新时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新时"}},[t._v("#")]),t._v(" 更新时")]),t._v(" "),e("p",[t._v("执行顺序: "),e("code",[t._v("render")]),t._v(" -> "),e("code",[t._v("componentDidUpdate()")])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("钩子函数")]),t._v(" "),e("th",[t._v("触发时机")]),t._v(" "),e("th",[t._v("作用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("render")]),t._v(" "),e("td",[t._v("每次组件渲染都会触发")]),t._v(" "),e("td",[t._v("渲染UI  (注意: 不能调用setState())")])]),t._v(" "),e("tr",[e("td",[t._v("componentDidUpdate(prevProps)")]),t._v(" "),e("td",[t._v("组件更新(完成DOM渲染)后")]),t._v(" "),e("td",[t._v("1. 发送网络请求 2. DOM操作")])])])]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("componentDidUpdate(prevProps) 注意事项")]),t._v(" "),e("p",[t._v("注意: 如果要调用setState必须放在一个if条件中,一般是判断更新前后的props是否相同来决定是否重新渲染组件,prevProps参数可以拿到上一次的props,通过this.props可以拿到当前的内容")])]),t._v(" "),e("p",[e("strong",[t._v("render触发时机")])]),t._v(" "),e("ol",[e("li",[t._v("传入新的props会触发render")]),t._v(" "),e("li",[t._v("调用setState()会触发render")]),t._v(" "),e("li",[t._v("forceUpdate()强制更新,触发render")])]),t._v(" "),e("h3",{attrs:{id:"卸载时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#卸载时"}},[t._v("#")]),t._v(" 卸载时")]),t._v(" "),e("p",[t._v("执行时机:组件从页面中消失")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("钩子函数")]),t._v(" "),e("th",[t._v("触发时机")]),t._v(" "),e("th",[t._v("作用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("componentWillUnmount")]),t._v(" "),e("td",[t._v("组件卸载(从页面消失)")]),t._v(" "),e("td",[t._v("执行清理工作:如定时器等")])])])])])}),[],!1,null,null,null);v.default=r.exports}}]);