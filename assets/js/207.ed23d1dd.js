(window.webpackJsonp=window.webpackJsonp||[]).push([[207],{794:function(t,a,v){"use strict";v.r(a);var r=v(58),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),v("p",[t._v("vue 路由传参\nparams query\nvue 周期")]),t._v(" "),v("p",[t._v("创建前后 挂载前后 更新前后 卸载前后")]),t._v(" "),v("p",[t._v("let var const")]),t._v(" "),v("h1",{attrs:{id:"var"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#var"}},[t._v("#")]),t._v(" var")]),t._v(" "),v("ol",[v("li",[t._v("var 如果不在函数内声明的变量是顶层变量,浏览器会挂载到window上,node会挂载到global上")]),t._v(" "),v("li",[t._v("var 声明的变量存在变量提升的情况")]),t._v(" "),v("li",[t._v("var 可以对一个变量进行多次声明,后面声明会覆盖前面的声明")])]),t._v(" "),v("h1",{attrs:{id:"let"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#let"}},[t._v("#")]),t._v(" let")]),t._v(" "),v("p",[t._v("let 关键字可以将变量绑定到所在的任意作用域中,通常是{} 的内部,换句话说let为其声明的变量隐式的劫持了所在的块作用域")]),t._v(" "),v("ol",[v("li",[t._v("不存在变量提升")]),t._v(" "),v("li",[t._v("不允许重复声明")]),t._v(" "),v("li",[t._v("let声明的变量只在当前作用域中生效")]),t._v(" "),v("li",[t._v("块级作用域")])]),t._v(" "),v("h1",{attrs:{id:"const"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#const"}},[t._v("#")]),t._v(" const")]),t._v(" "),v("p",[t._v("var 声明的变量会存在变量提升,并且var声明的变量是全局变量,会挂载到window上\nlet 和const 拥有块级作用域,有一个暂时性死区的特性\nconst 声明的变量,基础类型的值是不可修改的,引用类型保存的是地址,只要地址本身不变,其内容是可以修改的")])])}),[],!1,null,null,null);a.default=e.exports}}]);