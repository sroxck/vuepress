(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{709:function(t,a,e){"use strict";e.r(a);var s=e(58),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"等待唤醒机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#等待唤醒机制"}},[t._v("#")]),t._v(" 等待唤醒机制")]),t._v(" "),e("h2",{attrs:{id:"线程间通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程间通信"}},[t._v("#")]),t._v(" 线程间通信")]),t._v(" "),e("p",[t._v("多个线程在处理同一个资源,但是处理的动作(线程的任务)却不相同")]),t._v(" "),e("h2",{attrs:{id:"等待唤醒机制-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#等待唤醒机制-2"}},[t._v("#")]),t._v(" 等待唤醒机制")]),t._v(" "),e("p",[t._v("多个线程间的一种协作机制,线程间的通信,重点是有效的利用资源\n线程唤醒后,如果能获取到锁,线程从WAITING状态变成RUNNABLE状态,否则,从wait set出来,又进入entry set 线程从waiting变成blocked状态\n注意事项:")]),t._v(" "),e("ol",[e("li",[t._v("wiat和notify方法必须由同一个锁调用,因为:对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程")]),t._v(" "),e("li",[t._v("wait方法与notify方法是属于Object类的方法的,因为: 锁对象可以是任意对象,而任意对象的所属类都是继承了Object类的")]),t._v(" "),e("li",[t._v("wait方法与notify方法必须要在同步代码块或者是同步函数中使用,因为: 必须通过锁对象调用这个两个方法")])])])}),[],!1,null,null,null);a.default=i.exports}}]);